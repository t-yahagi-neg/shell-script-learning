#!/bin/bash

# ========================================
# パラメータ展開
# ========================================

# ----------------------------------------
# HOME変数をパラメータ展開
# ----------------------------------------
ls $HOME
# work
ls ${HOME}
# work

# ----------------------------------------
# :- による展開の例
# ----------------------------------------
echo ${name:-miyake}
# miyake		# 未定義の為指定したmiyakeと展開された
name=okita		# name変数に値を設定
echo ${name:-miyake}
# okita			# 空文字列ではない値を持つため、その値に展開された
#
# :- は、指定した変数が設定されているかどうかによって展開される値を切り替える
# ための記号。次のように書くと、「変数名」で指定した変数に空文字列以外の値
# が設定されているときはその値、そうでないときは「値」に書いた値に展開される
# ${変数名:-値}

# ----------------------------------------
# 引数のデフォルト値を設定する
# ----------------------------------------

#!/bin/bash

ls ${1:-/}

# シェルスクリプトの引数として指定したパスをlsコマンドで一覧表示する。
# 引数を省略した場合は${1:-/}の部分は/に展開されるので、
# ルートディレクトリの内容を一覧表示する。

# ----------------------------------------
# 指定する文字列に変数を利用
# ----------------------------------------
echo ${config_file:-$HOME/.conf}
# /home/miyake/.conf

# config_file変数が設定されていないときには$HOME/.confのHOME変数が展開される

# ----------------------------------------
# -によるパラメータ展開
# ----------------------------------------
name=		# 空文字列を設定
echo ${name-miyake}
		# 設定されている空文字列に展開された
name=okita
echo ${name-miyake}
okita		# 設定されている文字列okitaに展開された
unset name	# 変数を未定義状態にする
echo ${name-miyake}
miyake		# 指定したmiyakeに展開された

# :を省略して-だけにすると、空文字列かどうかにかかわらず
# 変数が設定されているかだけを判別するようになる

# ----------------------------------------
# :=による展開の例
# ----------------------------------------
echo ${name:=miyake}
miyake		# nameが設定されていないのでmiyakeに展開された
echo $name
miyake		# name変数に文字列"miyake"が設定された
name=okita
echo ${name:=miyake}
okita		# name変数に空文字列以外の値が設定されているため、その値に展開echo $name
okita		# name変数の値は変わらない

# 次のように書くと、「変数名」に空文字列以外の値が設定されている場合、
# その値に展開される。一方、「変数名」が設定されていないか値が空文字列である
# 場合は、「変数名」に「値」を設定(代入)した上で、「値」に展開される
# ${変数名:=値}


# ----------------------------------------
# 変数が未定義の為指定したエラーメッセージを表示
# ----------------------------------------
cd ${dir:?You must specify directory}
# -bash: dir: You must specify directory

# :?は、変数に値が設定されていない場合のエラー制御をするための記号
# ${変数名:?値}
# 「変数名」に空文字列以外の値が設定されている場合はその値に置き換わる
# そうでない場合は、「値」の内容が標準エラーに出力されて、シェルスクリプトは
# そこで終了する。「値」はエラーメッセージに相当する

# ----------------------------------------
# メッセージを省略
# ----------------------------------------
cd ${dir:?}
# -bash: dir: パラメータが null または設定されていません

# ----------------------------------------
# :+による展開
# ----------------------------------------

# :+は、:-とは逆に、変数に値が設定されているときに指定した値へ
# 展開するための記号
# ${変数名:+値}
# 「変数名」に空文字列でない値が設定されている場合、「値」に展開される
# そうでない場合は空文字列に展開される

# ----------------------------------------
# 変数の値の一部を取り出して出力
# ----------------------------------------
name=/usr/lib/karnel/
echo ${name:1}		# name変数の2文字目から末尾までを出力
# usr/lib/karnel/
echo ${name:2}		# name変数の3文字目から末尾までを出力
# sr/lib/karnel/

# ${変数名:数値}
# 「変数名」に設定された文字列の、「数値」の位置から末尾までに展開される。
# 「数値」は、配列のインデックスと同じく0から数える

# ----------------------------------------
# 「数値」に負の値を指定
# ----------------------------------------
name=/usr/lib/karnel/
echo ${name: -2}
# l/		# name変数の末尾2文字が出力された

# 文字列の末尾2文字を出力している。offsetに負の値を指定する場合は:-記法と
# 区別を付けるために、:と-の間に1つ以上のスペースを置く必要がある

# ----------------------------------------
# 変数の値から取り出す長さを指定して出力
# ----------------------------------------
name=/usr/lib/karnel/
echo ${name:1:5}	# 2文字目から5文字出力
# usr/l
echo ${name:2:100}	# 3文字目から100文字出力(末尾まで出力と解釈される)
# sr/lib/karnel/

# ${変数名:数値:長さ}と指定すると、「数値」の位置から、「長さ」分だけ、
# 変数から取り出される。上の例では、先頭1文字目から5文字取り出している
# 2つ目の例のようにlengthで指定した長さが元の文字列より長い場合は、
# 文字列の最後までを指定したことになる。

# ----------------------------------------
# 変数の値から取り出す長さに負の値を指定
# ----------------------------------------
name=/usr/lib/karnel/
echo ${name:2:-1}
# sr/lib/karnel

# 「長さ」も負の値を指定できる。その場合は取り出す文字数ではなく、
# 取り出す終了位置を指定したことになる。
# 上の例では、文字列の先頭2文字目から末尾1文字までを出力する

# ----------------------------------------
# 配列の一部の要素を取得
# ----------------------------------------
arr=(aaa bbb ccc ddd)
echo ${arr[@]:1}	# 配列の2番目から取得
# bbb ccc ddd

# 「変数名」の部分に配列名[@]または配列名[*]を指定すれば、「数値」で
# 指定したindexから末尾までの要素に展開される

# ----------------------------------------
# 配列の一部の要素をオフセットして取得
# ----------------------------------------
arr=(aaa bbb ccc ddd)
echo ${arr[@]:1:2}	# 配列の2番目から2つしゅとく
# bbb ccc

# 「長さ」もあわせて指定すると、「数値」から始まり「長さ」で指定した数の
# 要素に展開される

# ----------------------------------------
# 変数の値の文字数を出力
# ----------------------------------------
name=/etc/crontab
echo ${#name}
# 12

# 次のように記述すると、変数に含まれている文字数に展開され、変数が設定
# されていないか空文字列である場合は0に展開される
# ${#変数名}
# ${#配列名[@]}または${#配列名[*]}のように配列名を指定した場合は、
# その配列の要素数に展開される

# ----------------------------------------
# 最短マッチでパターンマッチした部分を取り除く
# ----------------------------------------
pref1=Aomori
echo ${pref1#Ao}
# mori

# 次の2つの記法は、変数の値から、「パターン」にマッチした部分を取り除いた
# 値に展開する
# ${変数名#パターン}	①
# ${変数名%パターン}	②
# ①は「パターン」に前方一致した部分を取り除いて、残りの部分に展開される。
# #が1つだけの場合は最短一致、##と2つの場合は最長一致でチェックする
# 上の例では、Aomoriという値のうち前方のAoの部分が取り除かれて、
# 残りのmoriが出力されている

# ----------------------------------------
# 何もマッチしないと何もしない
# ----------------------------------------
pref2=Akita
echo ${pref2#Ao}
# Akita

# ----------------------------------------
# 拡張子を取り出す(最短マッチ)
# ----------------------------------------
file=home.tar.gz
echo ${file#*.}
# tar.gz

# *.と指定すると、「任意の文字列の後に.が現れるまで」が取り除かれる。
# 結果としてhome.が取り除かれ、tar.gzが残る。
# ファイル名から拡張子を取り出すのによく使われる手法

# ----------------------------------------
# 拡張子を取り出す(最長マッチ)
# ----------------------------------------
file=home.tar.gz
echo ${file##*.}
# gz

# このファイル名の例では.が2回現れているが、##はそのうち長いほうにマッチ
# するので、home.tar.までが取り除かれてgzに展開される。
# 2つ以上の拡張子を持つファイルで、一番後ろの拡張子のみを取り出すには
# この手法を用いるとよい

# ----------------------------------------
# 拡張子を取り除く(最短マッチ)
# ----------------------------------------
file=home.tar.gz
echo ${file%.*}
# home.tar

# ②は、「パターン」に後方一致した部分を取り除く。この例では.は2つあるが、
# %の場合は最短一致、%%の場合は最長一致になる
# 上の例では.から始まって文字列の末尾まで任意の文字列を取り除く。　
# この例では.は2つあるが、%の場合はそのうち短いほうにマッチした部分が
# 取り除かれる。結果として、ファイル名から一番後ろの拡張子を
# 取り除くことができる

# ----------------------------------------
# 拡張子を取り除く(最長マッチ)
# ----------------------------------------
file=home.tar.gz
echo ${file%%.*}
# home

# %%とすると最長一致になるので、.tar.gzが取り除かれる。こうすると
# 2つ以上の拡張子を持つファイルで、すべての拡張子を取り除くことができる

# ----------------------------------------
# 先頭から最後の/までを取り除いてファイル名のみを取り出す
# ----------------------------------------
path=/var/local/backup/file.txt
echo ${path##*/}
# file.txt

# ファイルパスからファイル名部分やディレクトリ名部分だけを取り出す方法
# 上の例では、元の文字列の先頭から/までを最長一致で取り除いている

# ----------------------------------------
# 末尾から/までを取り除いてディレクトリ名のみを取り出す
# ----------------------------------------
path=/var/local/backup/file.txt
echo ${path%/*}
# /var/local/backup

# 上の例では、元の文字列の末尾から/までを最短一致で取り除いている

# ----------------------------------------
# 配列の各要素に対する操作
# ----------------------------------------
arr=(home.tar.gz file.zip)
echo ${arr[@]%%.*}
# home file

# 「変数名」に配列[@]または配列[*]のように指定すると、配列の各要素に対して
# この展開が行われる

# ----------------------------------------
# .を_に置き換える
# ----------------------------------------
file=home.tar.gz	# .を_に置換する
echo ${file/./_}
# home_tar.gz

#「変数名」に設定された値のうち「パターン」に一致した部分を、「置換文字列」
# に置換してから展開する
# ${変数名/パターン/置換文字列}
# 上の例では.が2つあるが、最初の.だけが置き換わる。このようにpatternにマッチ
# する部分が複数あった場合は、最初にマッチした部分だけが置換される。

# ----------------------------------------
# すべての.を_に置きかえる
# ----------------------------------------
file=home.tar.gz
echo ${file//./_}
# home_tar_gz

# パターン指定する前に/を2つ並べて//とすると、マッチした全ての部分が置換される

# ----------------------------------------
# .から末尾までを.txtに置換
# ----------------------------------------
file=home.tar.gz
echo ${file/.*/.txt}
# home.txt

# 「パターン」の部分には*などパス名展開と同じ記号が使用できる。この場合、
# マッチは最長一致となる
# .が2つあるが、最長一致となるため、.*でマッチした「.tar.gz」が「.txt」に
# 置き換わる
# 「パターン」の前の/を/#と書くと、patternが文字列の先頭にマッチしたときだけ
# 置換される。代わりに/%と書くと、文字列の末尾にマッチしたときだけ置換される。
# 文字列の先頭もしくは末尾部分を置き換えたいときに便利

# ----------------------------------------
# 末尾が.htmlの場合のみ.bakに置換する
# ----------------------------------------
file=file.html
echo ${file1/%.html/.bak}
# file.bak
file2=file.html.org
echo ${file2/*.html/.bak}
# file.html.org			.htmlで終わっていないので置換されていない

# 変数の値が.htmlで終わっている場合に限りそれを.bakに置換している。

# ----------------------------------------
# 配列の各要素のすべての.を_に置換
# ----------------------------------------
arr=(home.tar.gz file.zip)
echo ${arr[@]//./_}
# home_tar_gz  file_zip

# 他のパラメータ展開と同様に、変数名の部分として配列[@]または配列[*]のように
# 指定すると、配列の各要素に対してこの展開が行われる

# ----------------------------------------
# 
# ----------------------------------------


# ----------------------------------------
# 
# ----------------------------------------


# ----------------------------------------
# 
# ----------------------------------------



